<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Murmuration (1.0.0) üê¶‚ú®</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            font-family: 'Roboto', sans-serif;
            background: linear-gradient(to bottom, #0175C2, #1E1E1E);
            color: #ECEFF1;
        }

        header {
            background: #02569B;
            padding: 20px;
            text-align: center;
            box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.2);
        }

        header h1 {
            font-size: 2.5rem;
            margin: 0;
            color: #FFFFFF;
        }

        header p {
            margin: 5px 0 0;
            font-size: 1.1rem;
            color: #B3E5FC;
        }

        header .buttons {
            margin-top: 10px;
        }

        header .buttons a {
            text-decoration: none;
            background: #1E88E5;
            color: #FFFFFF;
            padding: 10px 15px;
            border-radius: 5px;
            margin: 5px;
            font-weight: 500;
            transition: background 0.3s;
        }

        header .buttons a:hover {
            background: #1565C0;
        }

        .content {
            max-width: 800px; /* Adjusted for better centering */
            margin: 20px auto;
            padding: 20px;
            background: #263238;
            border-radius: 10px;
            box-shadow: 0px 6px 10px rgba(0, 0, 0, 0.3);
            text-align: left; /* Align text to the left for better readability */
        }

        .content h2 {
            color: #0288D1;
            border-bottom: 2px solid #0288D1;
            padding-bottom: 5px;
        }

        .content code {
            background: #37474F;
            color: #81D4FA;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }

        .code-block {
            background: #37474F;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }

        .code-block pre {
            margin: 0;
            color: #ECEFF1;
        }

        .table-of-contents ul {
            list-style: none;
            padding: 0;
        }

        .table-of-contents ul li {
            margin: 5px 0;
        }

        .table-of-contents a {
            text-decoration: none;
            color: #03A9F4;
        }

        footer {
            text-align: center;
            padding: 10px;
            background: #02569B;
            margin-top: 20px;
            color: #B3E5FC;
        }

        footer a {
            color: #81D4FA;
            text-decoration: none;
        }
                .logo {
            max-width: 400px;
        }
    </style>
</head>

<body>
    <header>
        <img src="assets/logo.png" alt="Murmuration Logo" class="logo">
        <h1>Murmuration (1.0.0)</h1>
        <p>A Dart framework designed for orchestrating multi-agent interactions using Google's Generative AI models. It aims to facilitate seamless agent coordination and function execution, providing an ergonomic interface for constructing complex AI workflows.</p>
        <div class="buttons">
            <a href="https://github.com/AgnivaMaiti/murmuration" target="_blank">GitHub Repository</a>
        </div>
    </header>

    <div class="content">
        <h2>‚ö†Ô∏è WARNING</h2>
        <p>If you plan to use this in production, ensure you have proper error handling and testing in place as interaction with AI models can be unpredictable.</p>

        <h2>About Murmuration</h2>
        <p>The name "Murmuration" is inspired by the mesmerizing flocking behavior of birds, symbolizing the framework's focus on coordinated agent interactions and dynamic workflows. üê¶üí´</p>

        <h2>Table of Contents üìö</h2>
        <div class="table-of-contents">
 <ul>
                <li><a href="#installation">Installation</a></li>
                <li><a href="#quick-start">Quick Start</a></li>
                <li><a href="#key-features">Key Features</a></li>
                <li><a href="#core-concepts">Core Concepts</a></li>
                <li><a href="#progress-tracking">Progress Tracking</a></li>
                <li><a href="#streaming-support">Streaming Support</a></li>
                <li><a href="#debugging">Debugging</a></li>
                <li><a href="#error-handling">Error Handling</a></li>
                <li><a href="#api-reference">API Reference</a></li>
                <li><a href="#best-practices">Best Practices</a></li>
                <li><a href="#examples">Examples</a></li>
                <li><a href="#contributing">Contributing</a></li>
                <li><a href="#license">License</a></li>
            </ul>
        </div>

        <h2 id="installation">Installation ‚öôÔ∏è</h2>
        <p>Add to your <code>pubspec.yaml</code>:</p>
        <div class="code-block">
            <pre>dependencies:
  murmuration: ^latest_version
  google_generative_ai: ^latest_version</pre>
        </div>
        <p>Then run:</p>
        <div class="code-block">
            <pre>dart pub get</pre>
        </div>

        <h2 id="quick-start">Quick Start üöÄ</h2>
        <div class="code-block">
            <pre>import 'package:murmuration/murmuration.dart';
import 'package:google_generative_ai/google_generative_ai.dart';

void main() async {
  final config = MurmurationConfig(
    apiKey: 'your-api-key',
    model: 'gemini-1.5-flash-latest',
    debug: false,
    stream: false,
    logger: MurmurationLogger()
  );

  final murmur = Murmuration(config);

  final result = await murmur.run(
    input: "Hello!",
    agentInstructions: {
      'role': 'You are a helpful assistant.'
    },
    stateVariables: {},  // Optional initial state
    tools: [],           // Optional tools
    functions: {},       // Optional function handlers
    onProgress: null     // Optional progress callback
  );

  print(result.output);
}</pre>
        </div>

        <h2 id="key-features">Why Murmuration? ü§î</h2>
        <p>Murmuration is designed for situations where you need:</p>
        <ul>
            <li>Multiple specialized agents working together ü§ù</li>
            <li>Complex function calling and tool usage with specific response formats üîß</li>
            <li>State management and context preservation across agent interactions üìä</li>
            <li>Detailed progress tracking and logging üìà</li>
            <li>Real-time streaming of responses with configurable delay ‚è≥</li>
            <li>Integration with Google's Generative AI models üåê</li>
        </ul>

        <h2 id="examples">Examples</h2>
        <p>Explore practical implementations and detailed examples in the documentation.</p>

        <h2 id="core-concepts">Core Concepts üß†</h2>
        <h3>Agents</h3>
        <p>Agents are the fundamental building blocks in Murmuration. Each agent is powered by Google's GenerativeModel and encapsulates:</p>
        <ul>
            <li>Instructions defining its behavior</li>
            <li>Available tools and functions</li>
            <li>State management capabilities</li>
            <li>Progress reporting mechanisms</li>
        </ul>
        <div class="code-block">
            <pre>final agent = murmur.createAgent(
  {'role': 'You analyze data and provide insights.'},
  currentAgentIndex: 1,      // Optional: for chain positioning
  totalAgents: 1,            // Optional: total agents in chain
  onProgress: (progress) {   // Optional: progress tracking
    print(progress.toString());
  }
);

// Registering a function with proper type annotation
agent.registerFunction(
  'analyzeData',
  (Map<String, dynamic> params) {
    // Analyze data logic here
    return 'Analysis complete';
  }
);</pre>
        </div>

        <h3>Function Handlers and Response Format</h3>
        <p>Functions must follow a specific format for registration and invocation. The Agent class detects function calls by searching for the text "function:" in the model's response:</p>
        <div class="code-block">
            <pre>typedef FunctionHandler = dynamic Function(Map<String, dynamic>);

// Registering a function
void registerDataFunction(Agent agent) {
  agent.registerFunction('processData', (Map<String, dynamic> params) {
    // Access context variables if available
    final contextVars = params['context_variables'];
    // Process data
    return {'result': 'Processed data'};
  });
}

// Function call format in agent responses
// The agent must return text in this EXACT format:
// function: functionName(param1: value1, param2: value2)
// Note: The format must match exactly, including spaces after colons</pre>
        </div>

        <h3>Tools üõ†Ô∏è</h3>
        <p>Tools must be defined with complete schemas and type-safe execution functions:</p>
        <div class="code-block">
            <pre>final dataTool = Tool(
  name: 'data_processor',
  description: 'Processes raw data into structured format',
  schema: {
    'type': 'object',
    'properties': {
      'data': {'type': 'string'},
      'format': {'type': 'string'}
    }
  },
  execute: (Map<String, dynamic> params) {
    // Tool execution logic
    return 'Processed result';
  }
);

agent.registerTool(dataTool);</pre>
        </div>

        <h3>Agent Chains and State Management üîó</h3>
        <p>Create sequences of agents with state handoff. Note that the handoff method only copies state variables and doesn't transfer other agent properties:</p>
        <div class="code-block">
            <pre>final result = await murmur.runAgentChain(
  input: "Analyze this data",
  agentInstructions: [
    {'role': 'You clean and prepare data'},
    {'role': 'You analyze prepared data'},
    {'role': 'You create summaries of analysis'}
  ],
  tools: [],                    // Optional tools shared across chain
  functions: {},                // Optional functions shared across chain
  logProgress: true,            // Enable progress logging
  onProgress: (progress) {      // Optional progress callback
    print(progress.toString());
  }
);

// Access chain results
print(result.finalOutput);          // Final chain output
print(result.results.length);       // Number of agent results
print(result.progress.length);      // Number of progress records</pre>
        </div>

        <h2 id="progress-tracking">Progress Tracking üìä</h2>
        <p>Progress tracking includes timestamps and detailed status information:</p>
        <div class="code-block">
            <pre>final result = await murmur.run(
  input: "Process this task",
  onProgress: (progress) {
    print('Agent ${progress.currentAgent}/${progress.totalAgents}');
    print('Status: ${progress.status}');
    print('Output: ${progress.output}');
    print('Time: ${progress.timestamp}');
  }
);</pre>
        </div>

        <h2 id="streaming-support">Streaming Support üåä</h2>
        <p>Enable real-time streaming with configurable delay. The streaming implementation uses GenerativeModel's response text, splitting it into chunks with a 50ms delay:</p>
        <div class="code-block">
            <pre>final config = MurmurationConfig(
  apiKey: 'your-api-key',
  stream: true,  // Enable streaming
  debug: true    // Optional: enable debug logging
);

final murmur = Murmuration(config);
final result = await murmur.run(
  input: "Stream this response",
  onProgress: (progress) {
    print('Streaming: ${progress.status}');
  }
);

// Stream includes 50ms delay between chunks
// Chunks are created by splitting the response text on spaces
await for (final chunk in result.stream!) {
  print(chunk);
}</pre>
        </div>

        <h2 id="debugging">Debugging üêû</h2>
        <p>Enable comprehensive debug logging:</p>
        <div class="code-block">
            <pre>final config = MurmurationConfig(
  apiKey: 'your-api-key',
  debug: true,
  logger: MurmurationLogger(
    enabled: true,
    onLog: (message) {
      print('LOG: $message');
    },
    onError: (message) {
      print('ERROR: $message');
    }
  )
);</pre>
        </div>

        <h2 id="error-handling">Error Handling ‚ö†Ô∏è</h2>
        <p>Comprehensive error handling with original error preservation:</p>
        <div class="code-block">
            <pre>try {
  final result = await murmur.run(
    input: "Process this",
    agentInstructions: {'role': 'Assistant'}
  );

  // Check for stream availability
  if (result.stream != null) {
    await for (final chunk in result.stream!) {
      // Handle streaming response
    }
  } else {
    // Handle regular response
    print(result.output);
  }
} on MurmurationError catch (e) {
  print('Murmuration Error: ${e.message}');
  if (e.originalError != null) {
    print('Original Error: ${e.originalError}');
  }
} catch (e) {
  print('Unexpected Error: $e');</pre>
        </div>

        <h2 id="api-reference">API Reference üìñ</h2>
        <h3>MurmurationConfig</h3>
        <p>Configuration options for the Murmuration instance:</p>
        <div class="code-block">
            <pre>final config = MurmurationConfig(
  apiKey: 'required-api-key',
  model: 'gemini-1.5-flash-latest',  // Default model
  debug: false,                      // Default debug mode
  stream: false,                     // Default streaming mode
  logger: MurmurationLogger(         // Optional logger
    enabled: false,
    onLog: null,
    onError: null
  )
);</pre>
        </div>

        <h3>Agent Functions</h3>
        <p>Core agent manipulation methods:</p>
        <ul>
            <li><code>registerFunction(String name, FunctionHandler handler)</code>: Add custom function handlers</li>
            <li><code>registerTool(Tool tool)</code>: Add specialized tools</li>
            <li><code>updateState(Map<String, dynamic> newState)</code>: Modify agent state</li>
            <li><code>handoff(Agent nextAgent)</code>: Transfer state variables to another agent</li>
            <li><code>execute(String input)</code>: Run the agent with input</li>
        </ul>

        <h3>Result Types</h3>
        <div class="code-block">
            <pre>// Agent execution result
class AgentResult {
  final String output;
  final Map<String, dynamic> stateVariables;
  final List<String> toolCalls;
  final Stream<String>? stream;
  final List<AgentProgress>? progress;
}

// Chain execution result
class ChainResult {
  final List<AgentResult> results;
  final String finalOutput;
  final List<AgentProgress> progress;
}

// Progress tracking information
class AgentProgress {
  final int currentAgent;
  final int totalAgents;
  final String status;
  final String? output;
  final DateTime timestamp;
}</pre>
        </div>

        <h2 id="best-practices">Best Practices üèÜ</h2>
        <ol>
            <li><strong>State Management</strong>
                <ul>
                    <li>Use immutable state operations with <code>updateState()</code></li>
                    <li>Clear state between chain executions</li>
                    <li>Preserve context variables in state</li>
                    <li>Remember that handoff only copies state variables</li>
                </ul>
            </li>
            <li><strong>Function Design</strong>
                <ul>
                    <li>Always use <code>Map<String, dynamic></code> for parameters</li>
                    <li>Follow the exact function call format in responses</li>
                    <li>Handle missing or invalid parameters</li>
                    <li>Test function call string parsing extensively</li>
                </ul>
            </li>
            <li><strong>Error Handling</strong>
                <ul>
                    <li>Catch <code>MurmurationError</code> separately</li>
                    <li>Preserve original errors</li>
                    <li>Log errors through <code>MurmurationLogger</code></li>
                    <li>Handle <code>GenerativeModel</code> errors properly</li>
                </ul>
            </li>
            <li><strong>Progress Monitoring</strong>
                <ul>
                    <li>Implement <code>onProgress</code> callbacks</li>
                    <li>Track timing with timestamps</li>
                    <li>Log state transitions</li>
                    <li>Monitor streaming progress</li>
                </ul>
            </li>
            <li><strong>Tool Integration</strong>
                <ul>
                    <li>Define complete schemas</li>
                    <li>Include parameter validation</li>
                    <li>Document expected inputs/outputs</li>
                    <li>Test tool execution thoroughly</li>
                </ul>
            </li>
            <li><strong>Streaming</strong>
                <ul>
                    <li>Account for 50ms chunk delay</li>
                    <li>Handle stream availability</li>
                    <li>Implement proper stream cleanup</li>
                    <li>Consider chunk size implications</li>
                </ul>
            </li>
        </ol>

        <h2 id="contributing">Contributing ü§ù</h2>
        <p>Guidelines for contributing to Murmuration:</p>
        <ol>
            <li>Fork the repository</li>
            <li>Create a feature branch</li>
            <li>Submit a pull request</li>
        </ol>
        <p>Please ensure your code:</p>
        <ul>
            <li>Follows Dart conventions</li>
            <li>Is properly documented</li>
            <li>Handles errors appropriately</li>
            <li>Includes type annotations</li>
        </ul>

        <h2 id="license">License üìú</h2>
        <p>This project is licensed under the MIT License - see the <a href="https://github.com/AgnivaMaiti/murmuration/blob/main/LICENSE">LICENSE</a> file for details.</p>

        <h2 id="author">Author ‚úçÔ∏è</h2>
        <p>This project is authored by <a href="https://github.com/AgnivaMaiti">Agniva Maiti</a>.</p>
    </div>

    <footer>
        <p>Created by <strong>Agniva Maiti</strong> ¬© 2025.
    </footer>
</body>

</html>
